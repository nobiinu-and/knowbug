# knowbug
* version: ver: 1.0β18

## 概要
HSP3 用デバッグ・ウィンドウの非公式改造版です。

主に「変数」タブの機能を拡張しており、以下のものの表示に対応しています。

* int の16進数併記
* 多次元配列の2,3次元目
* 実行中のユーザ定義コマンドの実引数
* モジュール変数のメンバ

## 導入方法
#### knowbug

0. **HSPのフォルダ**にある「hsp3debug.dll」をバックアップします。
  * ファイルの名前を変更し、「hsp3debug_default.dll」などにするのがよいでしょう。
0. 次に、同梱されている「hsp3debug_knowbug.dll」の名前を「hsp3debug.dll」に変え、
HSPのフォルダにコピーします。

* 「HSPのフォルダ」
  * HSPがインストールされているフォルダで、「common」フォルダの1つ上です。
  * 通常は「C:/Program Files/hsp34」となります。数字は変わるかもしれません。

#### WrapCall

0. HSPのフォルダに同梱されている「WrapCall.as」と「userdef.as」を common フォルダに移動します。
  * 既に userdef.as を使っている方は、上書きではなく追記してください。

* WrapCall は一部機能にのみ使用するので、無くても問題ありません。
* WrapCall は hgimg3 などの拡張ランタイムと併用することができません。拡張ランタイムを使用する場合は、WrapCall.as を #include しないようにお願いします。

#### 設定ファイル「knowbug.ini」

特に重要でもないので、削除していただいて構いません。存在しない場合、既定の設定を用いて、正常に動作します。

具体的な設定については、設定ファイル内のコメントを参照してください。

## 除去方法

「導入方法」と逆の操作をします。なおレジストリなどに記録は残していません。

0. knowbug (ファイル名 hsp3debug.dll) を削除し、バックアップしておいた、元々の
hsp3debug.dll を、元に戻します。
0. 「knowbug.ini」「WrapCall.as」は不要なので削除します。

## 機能詳細
### 「全般」タブ

内容は本家とだいたい同じです (ランタイムから供給されるもの)。
win32gui版では、カレント・ポジション (pos) とカレント色 (color) も表示します。

### 「変数」タブ
#### ツリービュー

本家版とはレイアウトが異なり、画面を上下に二分して、上にツリービューが、下に
灰色メッセージボックスがあります。後者は、本家版と同じ働きです。

ツリーには、すべての静的変数の名前を、モジュールごとに分類して並べています。
この項目を選択すると、下のボックスに、変数の内容 (変数情報) が表示されます。

#### 静的変数

* 変数名:
  * 変数の名前です。
  * モジュールの中にある変数も、完全な名前 (\@ を含む) で表示します。
* 変数型:
   * 変数の型を次の形式で表します。
     * ``<vt><tq> <index>``
   * `<vt>` は変数の型の名前です。
   * `<tq>` は変数のモードを表します。通常は空("")です。
     * 変数がクローン変数 [^clone] のとき「&」と表示されます。
     * 変数が無効な状態のとき、「!」と表示されます。
   *  `<index>` は配列の形を表します。
     * 1次元配列の場合、「(x)」です。(x はその要素数)
     * 2次元配列の場合、「(x, y) (N in total)」と表示されます。
       * x, y はそれぞれ1,2次元目の要素数で、N は配列全体の要素数です。
     * 3,4次元配列の場合は、2次元配列と同様です。
   * 表示例：「int (2, 3) (6 in total)」
* アドレス:
  * 2つの8桁の16進数で表します。
  * 前者: 変数の実体データがあるメモリのアドレス (PVal::pt)
  * 後者: 変数のマスターデータがあるメモリのアドレス (PVal::master)
* サイズ:
  * ``using X of Y [byte]`` の形式で表します。
  * Y は実体データが「確保」しているメモリサイズ [byte] で、
  * X はそのうち、使用している部分のサイズです。
  * なお変数の型によっては X, Y がそれぞれ別の領域の大きさを指すことがあるため、``X > Y`` となることもありえます。

「アドレス」「サイズ」は、表示しないように設定することもできます。knowbug.ini をご参照ください。

変数がもつデータは、ツリー形式の文字列で表されます。基本的に本家と同じですが、配列やインスタンスは、特別な方法で表示します。凡例：
```
	(単体: 一次元一要素)
	要素名 = 値

	(一次元配列)
	要素名:
		.type = 型名[&] (要素数)
		要素リスト

	(多次元配列)
	要素名:
		.type = 型名[&] (要素数(1), ...) (全要素数 in total)
		要素リスト

	(インスタンス)
	要素名:
		.modcls = モジュール名[&]
		要素リスト
```
ここで、配列変数の型名についている記号「&」は、その変数がクローン変数 [^clone] であることを示します。    
インスタンスのモジュール名の後についている「&」は、そのインスタンスが、他のインスタンスへの参照であることを示します。

[^clone] クローン変数……dup や dupptr によって作られるもの
#### モジュール
モジュール名のノード(「@...」)自体を選択すると、そのモジュールが持つすべての
静的変数の値を、簡単に表示します。
```
	(モジュール)
	[@モジュール名]
	変数名	= 値
	...
```
#### システム変数
ルートに位置する「+sysvar」ノードの直下には、システム変数の項があります。

* cnt:
  * cnt は配列のように表示されます。第一項に相当するものが一番外側のループの cnt で、最後の値、 looplev 番目が現在の cnt の値になります。
  * repeat ループが実行中でないときは、「(out_of_loop)」と表示されます。
  * メモリダンプ範囲は HSPCTX::mem_loop[1～looplev] となっています。
```
(例)
	cnt:
		#(looplev) = (現在のcntの値)
		#(looplev-1) = 0
		...
		#1 = 0
	なお n = looplev となります。
```

* notebuf:
  * 「notebuf」はシステム変数ではありませんが、最後に notepad_sel で指定された (まだ notepad_unsel されていない) バッファを表示します。

「+sysvar」ノード自体を選択すると、すべてのシステム変数の値が簡単に表示されます。

#### 呼び出し
WrapCall 対応版を使用している場合、ルートに「+dynamic」ノードが存在します。
この直下には、呼び出されているユーザ定義コマンドのリストがあります。
それらを選択すると、以下の形式で、実引数を表示します：
```
	関数名：命令または関数の名前
	仮引数：(仮引数タイプ, ...)

	関数名:
		(0) = 第一引数の値
		(1) = 第ニ引数の値
		...
```
「(N)」は、N番目の仮引数を表します。仮引数の名前が表示されるかもしれません。\#modfunc, \#modcfunc の最初の引数の名前は「thismod」と表示されます。

呼び出しノードは、命令や関数がみつかった時点でツリービューに追加されます。以下の例でいうと、mystmt、myfunc がこの順番でノードに追加されます。
```hsp
#module
#deffunc mystmt
#defcfunc myfunc
#global

	mystmt "hello", myfunc()
```
myfunc を実行している間、mystmt の実引数の値は未確定なので、次のように表示されます。
```
	mystmt:
		arguments : (not_available)
```
また、本体の実行が始まった後も、実引数データにアクセスできないことがあり、その際もこの表示になります。例えば、newmod 命令によりコンストラクタ(\#modinit)が実行されている間など。

### 「ログ」タブ

フォント: "ＭＳ ゴシック", 9[pt]

* 自動更新チェックボックス:
  * これが付いている間、logmes 命令が実行されるたびに、「ログ」タブを更新します。
  * 更新は時間の掛かる処理です。たくさんの出力がある場合は、これを off にした方が高速になります。
* 呼出履歴チェックボックス:
  * これが付いている間、ユーザ定義コマンドの呼び出しが開始・終了するたびに、そのことがログに出力されます。
  * WrapCall と接続している場合にのみ有効です。

* 「更新」ボタン: ログを最新の状態に更新します。
* 「保存」ボタン: ログをファイルに保存します。
  * (ファイルを指定するダイアログが開きます。)
  * なお、設定ファイル(knowbug.ini)を用いて、終了時にログを自動保存するようにできます。
* 「初期化」ボタン:
  * ログを消去します。

### 実行制御

通常の「実行」「次行」「停止」ボタンの横に、加えて「次飛」「脱出」ボタンが
追加されています。

* 「実行」(Run):
  * assert 命令などで停止していた実行を再開します。
* 「次行」(Step In):
  * 次の命令を1つ実行して、再び停止します。
* 「停止」(Stop):
  * 実行を停止します。
* 「次飛」(Step Over):
  * 「次行」と同様に次の命令を実行しますが、それがユーザ定義命令・関数である場合は、その内部の実行が終了してから停止します。
  * これを押した後、マウスを動かすなどして、デバッグウィンドウにメッセージを送らないと実行位置の表示が更新されません。(既知の不具合)
```
(例)
	// ユーザ定義命令 test1, test2 があるとして
	assert
	test1	// ←今ここ！ (assert で停止した)
	test2

ここで「次飛」を使うと、

	test1	// test1 の実行が完了する
	test2	// ←今ここ！ (test2 の実行直前で停止する)

となる。
```
* 「脱出」(Step Out):
  * 次の return まで実行します。
  * ユーザ定義命令・関数の定義の中で使用すると、その命令が終了するところまで実行します。
```
(例)
	test1
	mes "hello"
	stop

	#deffunc test1
		assert
		mes "process"	// ←今ここ！ (assert で停止した)
		a = 1
		test2
		return

ここで「脱出」を使うと、

	test1			// test1 の実行が完了する
	mes "hello"		// ←今ここ！

となる。
```

## 動作環境
* HSP3.4β4 以降
* OS: Windows 7

これら以外では、動作を確認していません。サポートできない可能性も高いのでご了承ください。

## 権利
knowbug は、公式のデバッガ hsp3debug.dll に、上大が手を加えたものです。

本ソフトの半分程度は、OpenHSP にあるコード、およびリソースを使用しています (/trunk/tools/win32/hsp3debug/*)。Lisense フォルダの中身も参考にしてください。
```
	Copyright (C) 1997-2015, Onion Software/onitama.
	All rights reserved.
```

## 関連URL
* プログラ広場 <http://prograpark.ninja-web.net/>:
  * バグ報告、意見、感想、要望などは、ここの[掲示板](http://uedai-kami.bbs.fc2.com/)までお願いします。
  * 最新版は、ここの「[たまり場](http://prograpark.ninja-web.net/CollectField/)」にあります。
* HSPTV! <http://hsp.tv/>:
  * HSP3 の公式サイトです。
* OpenHSP <http://dev.onionsoft.net/trac/>:
  * プロジェクト OpenHSP のリポジトリがあるサイトです。
  * HSPはここで開発されています。
* knowbug on GitHub <https://github.com/vain0/knowbug/>:
  * knowbug のソースコードをアップロードしています。
  * 上大が作成した部分はご自由にお使いください。

## 既知の不具合
#### 原因不明なもの
* 条件付きステップ実行(次飛、脱出)が、knowbug ウィンドウに WindowMessage を送らないと動かない。
* ステップ実行のときに [×] で onexit の実行に移動し、再び [×] を押すとランタイムエラーが起きる。
* ソース小窓の更新時にときどき、ポーンと音が鳴り、新しい行のソースが(上書きではなく)追記される。

#### 対処不能なもの
* スクリプトやプラグインが ctx->prmstack を変更した場合、WrapCall がアクセス違反を犯す可能性が高い。
  * 特に、拙作 call.hpi とは共存できない。
* `@` から始まる名前の静的変数の変数情報を取得しようとすると、システムエラーで落ちる。
* 「Debug Window を表示しない」状態で実行すると、終了時にランタイムエラーが起こる。
  * その状態で WrapCall を使いユーザ定義コマンドを呼ぶと、システムエラーで落ちる。

## 更新予定
changes.md を参照してください。
