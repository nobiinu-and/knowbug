# コーディングガイド

コードを書くときの指針。ルールではないので、必ずしも守る必要はない

## C++

### 資料

- [江添亮のC++入門](https://ezoeryou.github.io/cpp-intro/)
- [C++日本語リファレンス](https://cpprefjp.github.io/)

### 名前付け

- マクロ: `SCREAMING_CASE`
- 型、型引数、テンプレート引数: `PascalCase`
- メンバ変数: `snake_case_` (末尾に `_`)
- 名前空間、ローカル変数、関数: `snake_case`

### フォーマット

- `const` や `*` は後置 (例 `char const*`)
- 関数の結果型は後置 (例 `auto f() -> ResultType {..}`) (void だけ前置)
- Visual Studio の「ドキュメントのフォーマット」になるべく従う
    - ただし「else の前に改行する」設定だけ変えて「改行しない」ようにしている

## HSP3

### 名前付け

原則として `snake_case` です。大文字は使わず、単語の間にアンダースコアを入れます。(例外: Win32 API の定数など)

- 変数: `s_xxx`
    - ただし引数や local 変数には `s_` をつけません。
    - メンバ変数は `xxx_` のように後ろにアンダースコアをつけます。
- ラベル: `l_xxx`
- モジュール名: `m_xxx`
- モジュールのファイル名: `mod_xxx.hsp`
- 命令・関数: `xxx_yyy`
    - ただし `xxx` はモジュール名とします。
    - 例えばファイル `mod_foo.hsp` に含まれるモジュール `m_foo` の中に定義される関数は `foo_yyy` のような名前になります。

---

## さらに細かいこと: C++

- `auto&&` などの基本的な使い分け
    - `auto&&`: (ユニバーサル参照)
        - range-based-for (`for (auto&& item : iter)`)
    - `auto const&`: (const左辺値参照)
        - `T const&` を返す関数の返り値をローカル変数に束縛するとき
        - ローカル変数の一部(メンバや配列要素)を別のローカル変数に束縛するとき、かつそれを変更しないとき (例 `auto const& item = array[i]; f(item);`)
    - `auto&`: (変更可能な左辺値参照)
        - `T&` を返す関数の返り値をローカル変数に束縛するとき (例 `auto& w = writer()`)
        - ローカル変数の一部(メンバや配列要素)を別のローカル変数に束縛するとき、かつそれを変更するとき (例 `auto& item = array[i]; item++`)
    - `auto`: (値をコピーして受け取る)
        - たいていはこれでOK
